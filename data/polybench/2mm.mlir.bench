func.func private @nanoTime() -> i64 attributes { llvm.emit_c_interface }
func.func @main(%A: memref<NIxNKxf64>, %B: memref<NKxNJxf64>, %C: memref<NJxNLxf64>, %D: memref<NIxNLxf64>, %alpha: memref<f64>, %beta: memref<f64>, %output: memref<NIxNLxf64>) -> i64 attributes { llvm.emit_c_interface } {
  %alpha_v = memref.load %alpha[] : memref<f64>
  %beta_v = memref.load %beta[] : memref<f64>
  %t0 = func.call @nanoTime() : () -> i64
  %tmp = memref.alloc() : memref<NIxNJxf64>
  linalg.generic {
    indexing_maps = [affine_map<(d0, d1)->(d0, d1)>],
    iterator_types = ["parallel", "parallel"]
  } outs(%tmp: memref<NIxNJxf64>) {
    ^bb0(%0: f64):
    %1 = arith.constant 0.0 : f64
    linalg.yield %1 : f64
  }
  linalg.generic {
    indexing_maps = [affine_map<(d0, d1, d2)->(d0, d2)>, affine_map<(d0, d1, d2)->(d2, d1)>, affine_map<(d0, d1, d2)->(d0, d1)>],
    iterator_types = ["parallel", "parallel", "reduction"]
  } ins(%A, %B: memref<NIxNKxf64>, memref<NKxNJxf64>) outs(%tmp: memref<NIxNJxf64>) {
    ^bb0(%2: f64, %3: f64, %4: f64):
    %5 = arith.mulf %2, %3 fastmath<nnan, ninf, nsz, reassoc, contract, afn> : f64
    %6 = arith.mulf %alpha_v, %5 fastmath<nnan, ninf, nsz, reassoc, contract, afn> : f64
    %7 = arith.addf %4, %6 fastmath<nnan, ninf, nsz, reassoc, contract, afn> : f64
    linalg.yield %7 : f64
  }
  linalg.generic {
    indexing_maps = [affine_map<(d0, d1)->(d0, d1)>, affine_map<(d0, d1)->(d0, d1)>],
    iterator_types = ["parallel", "parallel"]
  } ins(%D: memref<NIxNLxf64>) outs(%output: memref<NIxNLxf64>) {
    ^bb0(%8: f64, %9: f64):
    %10 = arith.mulf %beta_v, %8 fastmath<nnan, ninf, nsz, reassoc, contract, afn> : f64
    linalg.yield %10 : f64
  }
  linalg.generic {
    indexing_maps = [affine_map<(d0, d1, d2)->(d0, d2)>, affine_map<(d0, d1, d2)->(d2, d1)>, affine_map<(d0, d1, d2)->(d0, d1)>],
    iterator_types = ["parallel", "parallel", "reduction"]
  } ins(%tmp, %C: memref<NIxNJxf64>, memref<NJxNLxf64>) outs(%output: memref<NIxNLxf64>) {
    ^bb0(%11: f64, %12: f64, %13: f64):
    %14 = arith.mulf %11, %12 fastmath<nnan, ninf, nsz, reassoc, contract, afn> : f64
    %15 = arith.addf %13, %14 fastmath<nnan, ninf, nsz, reassoc, contract, afn> : f64
    linalg.yield %15 : f64
  }
  %t1 = func.call @nanoTime() : () -> i64
  %t2 = arith.subi %t1, %t0 : i64
  return %t2 : i64
}
