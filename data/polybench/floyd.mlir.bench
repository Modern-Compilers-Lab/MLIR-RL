func.func private @nanoTime() -> i64 attributes { llvm.emit_c_interface }
func.func @main(%P: memref<NxNxf64>) -> i64 attributes { llvm.emit_c_interface } {
  %t0 = func.call @nanoTime() : () -> i64
  linalg.generic {
    indexing_maps = [affine_map<(d0, d1, d2)->(d1, d0)>, affine_map<(d0, d1, d2)->(d0, d2)>, affine_map<(d0, d1, d2)->(d1, d2)>],
    iterator_types = ["reduction", "parallel", "parallel"]
  } ins(%P, %P: memref<NxNxf64>, memref<NxNxf64>) outs(%P: memref<NxNxf64>) {
    ^bb0(%arg0: f64, %arg1: f64, %arg2: f64):
    %1 = arith.addf %arg0, %arg1 fastmath<nnan, ninf, nsz, reassoc, contract, afn> : f64
    %2 = arith.cmpf olt, %arg2, %1 fastmath<nnan, ninf, nsz, reassoc, contract, afn> : f64
    %3 = arith.select %2, %arg2, %1 : f64
    linalg.yield %3 : f64
  }
  %t1 = func.call @nanoTime() : () -> i64
  %t2 = arith.subi %t1, %t0 : i64
  return %t2 : i64
}
